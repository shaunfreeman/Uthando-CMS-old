<?php

// no direct access
defined( 'PARENT_FILE' ) or die( 'Restricted access' );

class Admin_Config extends Config
{
	public $sync = false;
	public $protected_mode = true;
	public $public_html = false;
	
	public function __construct($registry, $options=null)
	{
		if ($options['sync'] && is_bool($options['sync'])) $this->sync = $options['sync'];
		if ($options['protected_mode'] && is_bool($options['protected_mode'])) $this->protected_mode = $options['protected_mode'];
		parent::__construct($registry, $options);
	}
	
	public function set($key, $value, $section=null)
	{
		try
		{
			// when sections are enabled and user tries to genarate non-sectioned vars, throw an error, this is definitely not allowed.
			if ($this->process_sections && !$section) throw new ConfigException("ConfigMagik::set() - Passed no section when in section-mode, nothing was set.");
			
			// set key with given value in given section (if enabled)
			if ( $this->process_sections):
				$this->vars[$section][$key] = $value;
			else:
				$this->vars[$key] = $value;
			endif;
			// synchronize memory with file when enabled
			if ($this->sync) $this->save();
			
			return true;
		}
		catch (ConfigException $e)
		{
			$this->registry->Error($e->getMessage());
			return false;
		}
	}
	
	public function removeKey($key, $section=null)
	{
		try
		{
			// check if section was passed and it's valid
			if ( $section!=null):
				if (in_array($section, array_keys($this->vars))==false) throw new ConfigException("Config::removeKey() - Could not find section('$section'), nothing was removed.");
				
				// look if given key exists in given section
				if (in_array( $key, array_keys($this->vars[$section]))===false) throw new ConfigException("Config::removeKey() - Could not find key('$key'), nothing was removed.");
				
				// remove key from section
				$pos = array_search($key, array_keys($this->vars[$section]), true);
				array_splice( $this->vars[$section], $pos, 1);
				return true;
			else:
				// look if given key exists
				if (in_array($key, array_keys($this->vars))===false) throw new ConfigException("Config::removeKey() - Could not find key('$key'), nothing was removed.");
				
				// remove key (sections disabled)
				$pos = array_search($key, array_keys($this->vars), true);
				array_splice( $this->vars, $pos, 1);
				// synchronisation-stuff
				if ($this->sync) $this->save();
				// return
				return true;
			endif;
		}
		catch (ConfigException $e)
		{
			$this->registry->Error($e->getMessage());
			return false;
		}
	}
	
	public function removeSection($section)
	{
		try
		{
			// check if section exists
			if (in_array($section, array_keys($this->vars), true)===false) throw new ConfigException("Config::removeSection() - Section('$section') could not be found, nothing removed.");
			
			// find position of $section in current config
			$pos = array_search($section, array_keys( $this->vars), true);
			// remove section from current config
			array_splice($this->vars, $pos, 1);
			// synchronisation-stuff
			if ($this->sync) $this->save();
			// return
			
			return true;
		}
		catch (ConfigException $e)
		{
			$this->registry->Error($e->getMessage());
			return false;
		}
	}
	
	public function removeAllSections()
	{
		$this->vars = array();
	}
	
	public function save()
	{
		try
		{
			if ($this->path == null) throw new ConfigException("Config::save() - ini path not set, error.");
			
			$content = null;
			// PROTECTED_MODE-prefix
			if ( $this->protected_mode) $content .= "<?php\n; /*\n; -- BEGIN PROTECTED_MODE\n";
			
			// config-header
			$content .= "; This file was automatically generated by Config\n";
			$content .= "; Do not edit this file by hand, use Config instead.\n";
			$content .= "; Last modified: ".date('d M Y H:i s')."\n";
			
			// check if there are sections to process
			if ($this->process_sections):
				foreach ($this->vars as $key => $elem):
					$content .= "[".$key."]\n";
					foreach ($elem as $key2 => $elem2):
						if (is_array($elem2)):
							foreach ($elem2 as $elem3):
								$content .= $key2."[] = \"".$elem3."\"\n";
							endforeach;
						else:
							$content .= $key2." = \"".$elem2."\"\n";
						endif;
					endforeach;
				endforeach;
			else:
				foreach ($this->vars as $key => $elem) $content .= $key." = \"".$elem."\"\n";
			endif;
			
			// add PROTECTED_MODE-ending
			if ($this->protected_mode) $content .= "\n; -- END PROTECTED_MODE\n; */\n?>\n";
			
			$ftp = new File_FTP($this->registry);
			
			$dir = preg_replace("/(.*?)".str_replace("/", "\/", $ftp->public_html)."|(.*?)".str_replace("/", "\/", $ftp->uthando_dir)."/", "", $this->path);
			
			if ($this->public_html):
				$path = $ftp->public_html.$dir;
			else:
				$path = $ftp->uthando_dir.$dir;
			endif;
			
			$ftp->chmod($path, 0646);
			if (!file_put_contents($this->path, $content)) throw new ConfigException("Config::save() - Could not write to file('".$this->path."'), error.");
			$ftp->chmod($path, 0644);
			$ftp->disconnect();
			return true;
		}
		catch (ConfigException $e)
		{
			$this->registry->Error($e->getMessage());
			return false;
		}
	}
	
	public function __toString()
	{
		$out  = "<pre>";
		ob_start();
		print_r($this->vars);
		$out .= ob_get_clean();
		$out .= "</pre>";
		return $out;
	}
	/*
	this method is to do. Something like this but using DOMElement.
	public function toHTML()
	{
		// render object as HTML
		$out  = "<table>\n";
		if ( $this->PROCESS_SECTIONS){
			// render with sections
			//$out .= "\t<tr><th style='border:1px solid white;'>Section</th><th style='border:1px solid white;'>Key</th><th style='border:1px solid white;'>Value</th></tr>\n";
			
			$sections = $this->listSections();
			$num_sections = 0;
			$num_keys     = 0;
			foreach ( $sections as $section){
				$out .= "\t<tr><th colspan='3'>$section</th></tr>\n";
				$keys = $this->listKeys( $section);
				foreach ( $keys as $key){
					$val  = $this->get( $key, $section);
					$out .= "\t<tr><th>$key</th><td colspan='2'>$val</td></tr>\n";
					$num_keys++;
				}
				$num_sections++;
			}
			// summary of table (with sections)
			$out .= "\t<tr><td colspan='3' align=right><code>There are <b>$num_keys keys</b> in <b>$num_sections sections</b>.</code></td></tr>\n";
		} else {
			// render without sections
			$keys     = $this->listKeys();
			$num_keys = 0;
			$out .= "\t<tr><th>Key</th><th>Value</th></tr>\n";
			foreach ( $keys as $key){
				$val  = $this->get( $key);
				$out .= "\t<tr><th>$key</th><td>$val</td></tr>\n";
				$num_keys++;
			}
			// summary of table (without sections)
			$out .= "\t<tr><td colspan='2' align=right><code>There are <b>$num_keys keys</b>.</code></td></tr>\n";
		}
			
		// close table
		$out .= "</table>";
		return $out;
	}
	*/
}

?>